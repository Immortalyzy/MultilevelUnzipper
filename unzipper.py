""" MultiLevelUnzipper - unzip multiple levels of zip files at once """
import os
import re
import shutil
import subprocess
import threading
import send2trash

from last_level import check_if_is_last_level
from setting import Config
from log_msg import log_msg

settings = Config.get_instance().settings

# regex for multi-part archives
multi_archive_regex = r"\.(?:part[2-9]\d*\.rar|r\d+|z\d+)$"


# get password list
def getPasswordList(dir_):
    """get the password list from the passwords.txt file (under current directory and under users home directory), return a list of passwords"""
    passwordList = [""]
    # check if dir_ is a file or a directory
    if os.path.isfile(dir_):
        dir_ = os.path.dirname(dir_)
    elif not os.path.isdir(dir_):
        log_msg(f"{dir_} is not a file or a directory", log_level=5)
        return passwordList

    # check if the password file exists
    if not os.path.exists(os.path.join(dir_, "passwords.txt")):
        log_msg("passwords.txt not found", log_level=5)
    else:
        # open with utf8 encoding
        with open(os.path.join(dir_, "passwords.txt"), "r", encoding="utf8") as f:
            for line in f:
                passwordList.append(line.strip())
    # print info message
    log_msg(
        f"Found {len(passwordList):d} passwords in local passwords.txt", log_level=3
    )

    # global password is stored in ~/.passwords.txt
    if os.path.exists(os.path.join(os.path.expanduser("~"), ".passwords.txt")):
        with open(
            os.path.join(os.path.expanduser("~"), ".passwords.txt"),
            "r",
            encoding="utf8",
        ) as f:
            for line in f:
                passwordList.append(line.strip())

    log_msg(f"Found {len(passwordList):d} passwords in total", log_level=4)
    return passwordList


def getPassInFileName(file):
    """get the password from the file name, return the password if found, otherwise return None"""
    # GENERATED BY CHATGPT

    # get the entire file name
    filename = os.path.basename(file)

    possible_passwords = []
    parts = filename.split("_")

    for i in range(1, len(parts)):
        # Build the potential password starting from each "_"
        pass_candidate = "_".join(parts[i:])

        # Check if there's a "." in the candidate
        if "." in pass_candidate:
            # Consider both with and without the extension as potential passwords
            without_extension = pass_candidate.split(".", 1)[0]
            possible_passwords.append(
                without_extension
            )  # Without considering "." as part of the password
            # Check if "." should be considered part of the password
            if pass_candidate.rfind(".") > pass_candidate.rfind("_"):
                possible_passwords.append(
                    pass_candidate
                )  # Considering "." as part of the password
        else:
            # No "." found, so the entire remainder is the password
            possible_passwords.append(pass_candidate)

    return possible_passwords


def remove_archive(file):
    """remove archive files just unzipped, finding all parts of multi-part archives and remove them"""
    # get the file list in the directory containing the file
    files = os.listdir(os.path.dirname(file))

    # get the base name of the file
    base_name = os.path.basename(file)

    # remove extensions
    base_name = base_name.split(".")[0]

    # combine the base name and the multi-part archive regex
    multi_archive_regex_of_this = (
        re.escape(base_name) + r"\.(?:part[2-9]\d*\.rar|r\d+|z\d+)$"
    )

    # find all files matching the multi-part archive regex
    multi_archives = [f for f in files if re.search(multi_archive_regex_of_this, f)]

    # delete all files matching the multi-part archive regex to the recycle bin
    log_msg(f"Removing {len(multi_archives):d} multi-part archives", log_level=3)
    for f in multi_archives:
        send2trash.send2trash(os.path.join(os.path.dirname(file), f))

    # delete the original file to the recycle bin
    send2trash.send2trash(file)


# unzip a file
def unzipFileWith7z(
    file,
    z7path,
    passwords,
    autodelete=False,
    autodeleteexisting=False,
    lv=0,
    maximum_lv=2,
):
    """principle function, unzip a file with 7z.exe, return True if success, otherwise return False"""
    has_archive = False
    password_protected = False

    # check if the file exists
    if not os.path.exists(file):
        log_msg(f"File {file} does not exist", log_level=5)
        return False, lv

    # check if is a .lib, .dll or .exe file, if yes skip
    # TODO: maybe a temporary solution, need to find a way to unzip .lib files
    if file.endswith(".lib") or file.endswith(".dll") or file.endswith(".exe"):
        log_msg(f"File {file} is a .lib, .dll or .exe file, skipping...", log_level=5)
        return False, lv

    # check if is a multi-archive sub archives, if yes skip
    if re.search(multi_archive_regex, file):
        log_msg(
            f"File {file} is a multi-archive non-principle part, skipping...",
            log_level=5,
        )
        return False, lv

    # check if the output directory already exists
    if os.path.exists(f"{file}lv{lv:d}"):
        if autodeleteexisting:
            log_msg(
                f"Output directory {file}lv{lv:d} already exists, deleting...",
                log_level=4,
            )
            shutil.rmtree(f"{file}lv{lv:d}")
        else:
            log_msg(
                f"Output directory {file}lv{lv:d} already exists, skipping...",
                log_level=4,
            )
            return False, lv

    # unzip without password
    # verify file is a a os.PathLike
    right_pass_found = False
    if not isinstance(file, os.PathLike) and not isinstance(file, str):
        raise TypeError(f"{file} must be a os.PathLike")

    log_msg(f"Unzipping {file} without password...", log_level=2)

    timer = threading.Timer(2, print, ["Unzipping is taking time, please wait..."])
    timer.start()
    result = subprocess.run(
        [z7path, "x", "-p", file, f"-o{file}lv{lv:d}"],
        capture_output=True,
        stdin=subprocess.DEVNULL,
        check=False,
    )
    timer.cancel()

    if (
        result.returncode == 2
        and result.stderr.decode("utf-8", errors="replace").find("Wrong password") != -1
    ):
        log_msg(
            f"Archive {file} is password protected, start to unzip with passwords...",
            log_level=2,
        )
        shutil.rmtree(f"{file}lv{lv:d}", ignore_errors=True)
        has_archive = True
        password_protected = True
    if (
        result.returncode == 2
        and result.stderr.decode("utf-8", errors="replace").find(
            "Cannot open the file as archive"
        )
        != -1
    ):
        if lv == 0:
            log_msg(f'File "{file}" is not an archive', log_level=4)
        # remove the empty directory due to file is not an archive
        shutil.rmtree(f"{file}lv{lv:d}", ignore_errors=True)
        return False, lv
    if result.returncode == 0:
        log_msg(
            f"Archive {file} is not password protected, unzipped to {file}lv{lv:d}",
            log_level=3,
        )
        right_pass_found = True
        has_archive = True
    elif password_protected is False:
        log_msg(f"Unknown error when unzipping {file}", log_level=5)
        log_msg(result.stderr.decode("utf-8", errors="replace"), log_level=5)
        return False, lv

    # try to unzip with password in file name
    if password_protected and not right_pass_found:
        passwords_in_file = getPassInFileName(file)
        # add these passwords to be begining of the passwords list
        if passwords_in_file is not None:
            passwords = passwords_in_file + passwords
            for password in passwords_in_file:
                timer = threading.Timer(
                    2,
                    print,
                    [
                        f"Unzipping is taking time (password is {password}), please wait..."
                    ],
                )
                timer.start()
                result = subprocess.run(
                    [z7path, "x", f"-p{password}", file, f"-o{file}lv{lv:d}"],
                    capture_output=True,
                    stdin=subprocess.DEVNULL,
                    check=False,
                )
                timer.cancel()
                if (
                    result.returncode == 2
                    and result.stderr.decode("utf-8", errors="replace").find(
                        "Wrong password"
                    )
                    != -1
                ):
                    # remove empty files created due to wrong password
                    shutil.rmtree(f"{file}lv{lv:d}", ignore_errors=True)
                else:
                    log_msg(
                        f"Correct password for {file} is {password} (contained in file name), unzipped to {file}lv{lv:d}",
                        log_level=3,
                    )
                    has_archive = True
                    right_pass_found = True
                    break

    # unzip with password
    if password_protected and not right_pass_found:
        for password in passwords:
            timer = threading.Timer(
                2,
                print,
                [f"Unzipping is taking time (password is {password}), please wait..."],
            )
            timer.start()
            result = subprocess.run(
                [z7path, "x", f"-p{password}", file, f"-o{file}lv{lv:d}"],
                capture_output=True,
                stdin=subprocess.DEVNULL,
                check=False,
            )
            timer.cancel()
            if (
                result.returncode == 2
                and result.stderr.decode("utf-8", errors="replace").find(
                    "Wrong password"
                )
                != -1
            ):
                # remove empty files created due to wrong password
                shutil.rmtree(f"{file}lv{lv:d}", ignore_errors=True)
            else:
                log_msg(
                    f"Correct password for {file} is {password}, unzipped to {file}lv{lv:d}",
                    log_level=3,
                )
                has_archive = True
                right_pass_found = True
                if autodelete:
                    # delete the original file if autodelete is True
                    remove_archive(file)

                break

    # no password found for the file
    if not right_pass_found:
        log_msg(f"Cannot find the correct password for {file}", log_level=5)
        return False, lv

    # trying to unzip the files in the directory just created
    if has_archive:
        # check if is the last level
        if check_if_is_last_level(f"{file}lv{lv:d}"):
            # the file just unzipped is the final level
            return False, lv

        log_msg(
            f"Archive {file} has been unzipped to {file}lv{lv:d}, going to next level",
            log_level=3,
        )
        lv += 1
        # recursively unzip the files in the directory just created
        for root, dirs, files in os.walk(f"{file}lv{lv-1:d}"):
            for file in files:
                unzipFileWith7z(
                    os.path.join(root, file),
                    z7path,
                    passwords,
                    autodelete,
                    autodeleteexisting,
                    lv,
                )
        return True, lv
    return False, lv


def move_files_up(dir_path):
    """remove all redundant directories and move all files up to the first level"""
    contents = os.listdir(dir_path)
    log_msg(f"Moving files up in {dir_path}", log_level=3)

    if len(contents) == 1 and os.path.isdir(os.path.join(dir_path, contents[0])):
        subdir_path = os.path.join(dir_path, contents[0])
        if os.path.isdir(subdir_path):
            subdir_contents = os.listdir(subdir_path)
            for item in subdir_contents:
                shutil.move(os.path.join(subdir_path, item), dir_path)
            os.rmdir(subdir_path)
            move_files_up(dir_path)
